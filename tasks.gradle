import org.apache.tools.ant.taskdefs.condition.Os

ext.composeDir = layout.buildDirectory.dir("compose").get().asFile.path
ext.composeFilesPattern = '**/compose/*.yml'
def propertiesFile = 'gradle.properties'

ext.isBBDDEnabled = project.hasProperty("docker_com.etendoerp.docker_db") ? project.property("docker_com.etendoerp.docker_db").toBoolean() : false
ext.isTomcatEnabled = project.hasProperty("docker_com.etendoerp.tomcat") ? project.property("docker_com.etendoerp.tomcat").toBoolean() : false
ext.tomcatPort = project.hasProperty("tomcat.port") ? project.property("tomcat.port").toString() : "8080"
ext.contextName = project.hasProperty("context.name") ? project.property("context.name").toString() : "etendo"

ext.envFile = { ->
    def envFile = file(layout.buildDirectory.dir("compose/.env").get().asFile)
    if (!envFile.parentFile.exists()) {
        envFile.parentFile.mkdirs()
    }
    if (!file(propertiesFile).exists()) {
        throw new GradleException("gradle.properties file not found")
    }
    def properties = new Properties()
    file(propertiesFile).withInputStream { input ->
        properties.load(input)
    }
    return [properties: properties, envFile: envFile]
}

/**
 * Inserts or updates a key=value line in a .env file.
 *
 * @param key String  – name of the property (e.g. 'OTEL_CONFIG_ENABLE')
 * @param value Object  – value you want to set (e.g. 'true')
 */
ext.upsertEnvProperty = { String key, Object value ->
    def envFile = envFile().envFile
    def strValue = value.toString()
    String newLine = "${key}=${strValue}"
    List<String> lines = new ArrayList<>(envFile.readLines('UTF-8'))
    int idx = lines.findIndexOf { it.trim().startsWith("${key}=") }
    if (idx >= 0) {
        lines[idx] = newLine
    } else {
        lines << newLine
    }
    envFile.withWriter('UTF-8') { writer ->
        lines.each { writer.writeLine(it) }
    }
}

/**
 * Lookup a project property by name and coerce it into
 * Boolean, Integer, BigDecimal, or String as appropriate.
 *
 * @param key the property name
 * @return typed value (Boolean, Integer, BigDecimal, or String), or null if absent
 */
ext.getTypedProp = { String key ->
    if (!project.hasProperty(key)) {
        return null
    }
    def raw = project.property(key)
    if (raw instanceof Boolean) {
        return raw
    }
    String s = raw.toString().trim()
    // boolean?
    if (s.equalsIgnoreCase('true') || s.equalsIgnoreCase('false')) {
        return s.toBoolean()
    }
    // integer?
    if (s.isInteger()) {
        return s.toInteger()
    }
    // decimal?
    if (s ==~ /^\d+\.\d+$/) {
        return s.toBigDecimal()
    }
    // fallback to string
    return s
}

/**
 * Retrieves legacy properties from a configuration file located in the project's config directory.
 * The configuration file is "Openbravo.properties".
 * @return A Properties object containing the properties from the configuration file.
 *         If the file does not exist, an empty Properties object is returned.
 */
def getLegacyProperties = { ->
    def configFile = file("$projectDir/config/").listFiles().find { (it.name == "Openbravo.properties") }
    def properties = new Properties()
    project.logger.info("Reading properties from: $configFile")
    if (configFile == null || !configFile.exists()) {
        project.logger.info("File not found: $configFile")
        return properties
    }
    configFile.withInputStream { input ->
        properties.load(input)
    }
    return properties
}

/**
 * Converts a given key to a standardized format.
 * The method performs the following transformations:
 * 1. Inserts an underscore between lowercase and uppercase letters.
 * 2. Converts the entire string to uppercase.
 * 3. Replaces periods with underscores.
 *
 * @param key the input string to be standardized
 * @return the standardized key as a string
 */
def standarizeKey(key) {
    return key.replaceAll(/([a-z])([A-Z])/, '$1_$2').toUpperCase().replace('.', '_')
}

/**
 * Task: generateEnvFile
 *
 * Description:
 * Converts gradle.properties configurations into a .env file located in build/compose/.env.
 *
 * Group:
 * Docker
 *
 * Details:
 * - Reads properties from gradle.properties and legacy properties.
 * - Writes these properties to a .env file, excluding the 'volumes.path' property.
 * - Standardizes property keys before writing.
 * - Ensures that legacy properties do not overwrite existing properties from gradle.properties.
 * - Sets the VOLUMES_PATH in the .env file, defaulting to "$buildDir/../volumes" if not specified.
 * - Sets the DOCKER_BBDD_PROFILE based on the isBBDDEnabled flag.
 * - Creates the directory specified by VOLUMES_PATH if it does not exist.
 *
 * Outputs:
 * - Generates a .env file at the specified location.
 */
task generateEnvFile {
    description = 'Converts gradle.properties configurations into a .env file in build/compose/.env'
    group = 'Docker'

    doLast {
        def volumesPathKey = 'volumes.path'
        def props = envFile()
        def env = props.envFile
        def properties = props.properties
        def legacyProperties = getLegacyProperties()
        def keys = []
        env.withWriter { writer ->
            project.logger.debug("Generating .env file with properties: ")
            properties.each { key, value ->
                if (key == volumesPathKey) {
                    return
                }
                def envKey = standarizeKey(key.toString())
                keys.add(envKey)
                project.logger.debug("Writing property: $envKey=$value")
                writer.write("${envKey}=${value}\n")
            }
            project.logger.debug("Generating .env file with legacy properties:")
            legacyProperties.each { key, value ->
                if (key == volumesPathKey) {
                    return
                }
                def envKey = standarizeKey(key.toString())
                if (keys.contains(envKey)) {
                    project.logger.debug("Skipping legacy property: $envKey=$value due gradle.properties already contains it.")
                } else {
                    project.logger.debug("Writing legacy property: $envKey=$value")
                    writer.write("${envKey}=${value}\n")
                }
            }
            def defaultVolumesPath = new File(project.layout.buildDirectory.asFile.get(), "../volumes").canonicalPath
            def volumesPath = properties.getProperty(volumesPathKey, defaultVolumesPath)
            writer.write("VOLUMES_PATH=${volumesPath}\n")
            if (isBBDDEnabled) {
                writer.write("DOCKER_BBDD_PROFILE=default\n")
            } else {
                writer.write("DOCKER_BBDD_PROFILE=disabled\n")
            }
            writer.write("TOMCAT_PORT=${tomcatPort}\n")
            new File(volumesPath).mkdirs()
        }
        // DB Resource Limits
        def dbServiceFactors = [
                DB: [mem: 1.0, cpu: 1.0]  // Default 256Mb - 1 Cpu
        ]
        def DB_BASE_MEM_MB = getTypedProp("db.base.memory.mb")
        if (DB_BASE_MEM_MB != null) {
            dbServiceFactors.each { service, factors ->
                def memMB = (DB_BASE_MEM_MB * factors.mem).toInteger()
                upsertEnvProperty("BASE_${service}_MEMORY_LIMIT", "${memMB}M")
            }
        }
        def DB_BASE_CPU = getTypedProp("db.base.cpu")
        if (DB_BASE_CPU != null) {
            dbServiceFactors.each { service, factors ->
                def cpu = ((DB_BASE_CPU * factors.cpu) as BigDecimal).setScale(1, BigDecimal.ROUND_HALF_UP).toString()
                upsertEnvProperty("BASE_${service}_CPU_LIMIT", "${cpu}")
            }
        }
        println "Generated .env file at: $env"

    }
}


task copyComposeFiles {
    description = 'Finds all Docker Compose YAML files and copies them to build/compose'
    group = 'Docker'
    dependsOn 'generateEnvFile'

    doLast {
        def destDir = file(composeDir)
        if (!destDir.exists()) {
            destDir.mkdirs()
        } else {
            destDir.eachFile { file ->
                if (file.name.endsWith(".yml")) {
                    file.delete()
                }
            }
        }
        destDir.mkdirs()
        def dirs = ['modules', "${layout.buildDirectory.get().asFile}/etendo/modules"]
        dirs.each { dir ->
            {
                fileTree(dir: dir, include: composeFilesPattern).each { file ->
                    def module = file.name.replaceFirst(/.yml/, '')
                    if (file.name == "docker-compose.yml" ||
                            (project.hasProperty("docker_" + module) &&
                                    project.property("docker_" + module) == "true")) {
                        println "Using Docker Compose file: $file"
                        copy {
                            from file
                            into destDir
                        }
                    } else {
                        println "Skipping Docker Compose file: $file"
                    }
                }
            }
        }

        destDir.eachFileMatch(~/.*\.yml/) { file ->
            file.text = file.text.replace('{CONFIG_URL}', isTomcatEnabled ? "tomcat" : "host.docker.internal")
        }

    }
}
ext.executeDockerCommand = { String shellCmd ->
    println "Checking if Docker is running..."

    def dockerRunning = false
    try {
        def process = new ProcessBuilder("docker", "info")
                .redirectErrorStream(true)
                .start()
        if (!process.waitFor(30, java.util.concurrent.TimeUnit.SECONDS)) {
            println "Docker command timed out, assuming Docker is not running."
            process.destroyForcibly()
        } else if (process.exitValue() == 0) {
            dockerRunning = true
        }
    } catch (Exception e) {
        println "Error checking Docker: ${e.message}"
    }
    if (!dockerRunning) {
        throw new GradleException("Docker is not running. Please start the Docker service.")
    }
    def output = new ByteArrayOutputStream()
    println "⚙️ Executing Docker command: ${shellCmd}"
    def osCmd = Os.isFamily(Os.FAMILY_WINDOWS)
      ? ['cmd','/c', shellCmd]
      : ['bash','-lc', shellCmd]
    def result = exec {
        commandLine osCmd
        standardOutput = output
        errorOutput = output
        ignoreExitValue = true
    }
    if (result.exitValue != 0) {
        throw new GradleException("The command fails:\n" + output.toString())
    }
    // store in build/compose/logs the output of the last successful command
    def logsDir = file("$composeDir/logs")
    if (!logsDir.exists()) {
        logsDir.mkdirs()
    }
    // get current timestamp to add it to the log file name
    def timestamp = new Date().format("yyyyMMdd_HHmmss")
    // create the log file with the timestamp
    def logFile = file("$logsDir/build-timestamp-${timestamp}.log")
    logFile.text = output.toString()
    println output.toString()
}

ext.executeDockerComposeCommand = { String action ->
    def composeFiles = fileTree(dir: composeDir, include: '*.yml').files
    if (composeFiles.size() <= 1) {
        throw new GradleException("Currently, there are no Docker-enabled resources available.")
    }
    println "Checking if Docker is running..."

    def dockerRunning = false
    try {
        def process = new ProcessBuilder("docker", "info")
                .redirectErrorStream(true)
                .start()
        if (!process.waitFor(30, java.util.concurrent.TimeUnit.SECONDS)) {
            println "Docker command timed out, assuming Docker is not running."
            process.destroyForcibly()
        } else if (process.exitValue() == 0) {
            dockerRunning = true
        }
    } catch (Exception e) {
        println "Error checking Docker: ${e.message}"
    }
    if (!dockerRunning) {
        throw new GradleException("Docker is not running. Please start the Docker service.")
    }

    def command = ['docker', 'compose', "--profile", "default"]
    composeFiles.each { file ->
        command << '-f' << file.absolutePath
    }
    action.split(" ").each { arg ->
        command << arg
    }

    // Add --scale service=0 for excluded services from docker.exclude property, in case of up action
    if (action.startsWith("up -d") && project.hasProperty("docker.exclude")) {
        def excludedServices = project.property("docker.exclude")
                .split(',')
                .collect { it.trim() }
                .findAll { it }

        excludedServices.each { service ->
            command << '--scale' << "${service}=0"
        }
    }
    println "Running: $command"
    def os_cmd = []
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        os_cmd = ['cmd', '/c'] + command
    } else {
        def lastCommandFile = file("$composeDir/.last-command")
        lastCommandFile.text = command.join(' ')
        os_cmd = ['sh', "$composeDir/.last-command"]
    }
    def outputStream = new ByteArrayOutputStream()
    def result = exec {
        commandLine os_cmd
        standardOutput = outputStream
        errorOutput = outputStream
        ignoreExitValue = true
    }
    if (result.exitValue != 0) {
        throw new GradleException("The command fails:\n" + outputStream.toString())
    }
    // store in build/compose/logs the output of the last successful command
    def logsDir = file("$composeDir/logs")
    if (!logsDir.exists()) {
        logsDir.mkdirs()
    }
    // get current timestamp to add it to the log file name
    def timestamp = new Date().format("yyyyMMdd_HHmmss")
    // create the log file with the timestamp
    def logFile = file("$logsDir/build-timestamp-${timestamp}.log")
    logFile.text = outputStream.toString()
    println outputStream.toString()
}

task "resources.up" {
    description = 'Runs docker compose to bring up the Docker services'
    group = 'Docker'
    dependsOn copyComposeFiles

    doLast {
        executeDockerComposeCommand('up -d --build')
        executeDockerCommand('docker image prune -f')
    }
}

task "resources.down" {
    description = 'Runs docker compose to bring down the Docker services'
    group = 'Docker'
    dependsOn copyComposeFiles

    doLast {
        executeDockerComposeCommand('down')
    }
}

task "resources.stop" {
    description = 'Runs docker compose to stop the Docker services'
    group = 'Docker'
    dependsOn copyComposeFiles

    doLast {
        executeDockerComposeCommand('stop')
    }
}

task "resources.build" {
    description = 'Runs docker compose to build the Docker services'
    group = 'Docker'
    dependsOn copyComposeFiles

    doLast {
        executeDockerComposeCommand('build --no-cache')
        executeDockerCommand('docker image prune -f')
    }
}

afterEvaluate {
    tasks.named("smartbuild").configure { task ->
        task.dependsOn("copyComposeFiles")
    }
    tasks.named("compile.complete").configure { task ->
        task.dependsOn("copyComposeFiles")
    }
    tasks.named("resources.build").configure {
        finalizedBy("resources.up")
    }
}
